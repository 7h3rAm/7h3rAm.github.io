<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="author" content="7h3rAm"/>
    <meta name="description" content="Personal Weblog"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>Grey Matter</title>

    <link href="/static/css/default.css" rel="stylesheet" type="text/css">
    <link href="/static/css/codehilite/perldoc.css" rel="stylesheet" type="text/css">

    <link href="/static/images/favicon-32x32.png" sizes="32x32" rel="icon" type="image/png"/>
  </head>
  <body>
    <section id="content" class="body">
              <div class="header">
          <table>
            <tr>
              <td class="blogtitle"><a href="/" style="color: rgb(102, 102, 102);">Grey Matter</a></td>
              <td class="blognavbar">
                [<a id="archive" href="/archive.html" style="color: rgb(70, 130, 180);">Archive</a>] [<a id="tags" href="/tags.html" style="color: rgb(255, 183, 69);">Tags</a>] [<a id="projects" href="/projects.html" style="color: rgb(0, 128, 128);">Projects</a>] [<a id="research" href="/research.html" style="color: rgb(242, 119, 122);">Research</a>]
              </td>
            </tr>
          </table>
        </div>
                  <article class="post">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel panel-default section compact">
        <div class="body">
          <p class="heading">Exploit Mitigation Techniques on Linux Systems</p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <p class="date">
                  <a href="/2012/vuln-weekends-8.html">&lt&lt;</a> published on 10/Jul/2012<a href="/2012/geras-wuos-stack1-solutions.html"> &gt;&gt;</i></a><br/>
                </p>
                                                                                                                                                                                                                                                  <div class="post-content">
          <p>Each year we see phenomenal research work being presented in a number of
security conferences and events around the world. Vendors/communities
present solutions for existing issues and those on the offensive side
present workarounds against these solutions. Eventually this race,
between those working on either sides of the coin, helps to make our
world a safer place.</p>

<p>Over the last decade, reliable exploitation of memory corruption bugs
has become extremely difficult. This has happened, primarily, due to the
introduction of various exploit mitigation techniques. In this post,
we&#8217;ll be looking at the current state of exploitation within the Linux
environment.The following security/mitigation techniques are commonly
available on most recent distributions:</p>

<ol>
<li>ASLR</li>
<li>NX</li>
<li>Stack Canaries</li>
<li>FORTIFY_SOURCE</li>
<li>RELRO</li>
<li>PIE</li>
</ol>

<p>Except for ASLR, which effects system-wide configuration, all of the
other techniques are user-space mitigation features that have to be
enabled on a per-binary basis. Here is the sample program that we&#8217;ll be
using for our tests:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main () {
  char array[80];
  printf ("&amp;array: %p\n", &amp;array);
  gets (array);
  printf ("*array: {\"%s\"}\n", array);
  return 0;
}
</code></pre>

<p>Let&#8217;s have a detailed look at each of the above techniques:</p>

<h3>Address Space Layout Randomization - ASLR</h3>

<p>Enables randomization of  various memory allocation segments (<code>stack</code>,
<code>mmap</code>, <code>exec</code>, <code>brk</code>, and <code>vdso</code>). When enabled, each invocation of a
binary will have its memory allocations randomized within the available
virtual address space on the system. As such, an exploit technique like
<a href="http://en.wikipedia.org/wiki/Return-to-libc_attack">Ret2libc</a>, that
requires static memory addresses of common library functions, is no
longer effective:</p>

<pre><code># sysctl kernel.randomize_va_space
kernel.randomize_va_space = 2
#
# sysctl -w kernel.randomize_va_space=0
kernel.randomize_va_space = 0
#
# cat /proc/sys/kernel/randomize_va_space
0
# echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>The randomize<em>va</em>space kernel parameter defines system-wide
configuration setting for ASLR. This parameter could be set to the
following values:</p>

<ul>
<li>0: ASLR is turned OFF</li>
<li>1: ASLR is turned ON (stack randomization)</li>
<li>2: ASLR is turned ON (stack, heap, and mmap allocation randomization)</li>
</ul>

<p>Once enabled, each invocation of a program will have different memory
locations assigned to it:</p>

<pre><code># cat /proc/self/maps
08048000-08054000 r-xp 00000000 08:01 261660     /bin/cat
08054000-08055000 r--p 0000b000 08:01 261660     /bin/cat
08055000-08056000 rw-p 0000c000 08:01 261660     /bin/cat
0827b000-0829c000 rw-p 00000000 00:00 0          [heap]
b7588000-b75c7000 r--p 00000000 08:01 415795     /usr/lib/locale/en_US.utf8/LC_CTYPE
b75c7000-b75c8000 r--p 00000000 08:01 415800     /usr/lib/locale/en_US.utf8/LC_NUMERIC
b75c8000-b76e6000 r--p 00000000 08:01 415794     /usr/lib/locale/en_US.utf8/LC_COLLATE
b76e6000-b76e7000 rw-p 00000000 00:00 0
b76e7000-b783a000 r-xp 00000000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b783a000-b783b000 ---p 00153000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b783b000-b783d000 r--p 00153000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b783d000-b783e000 rw-p 00155000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b783e000-b7841000 rw-p 00000000 00:00 0
b7841000-b7842000 r--p 00000000 08:01 415834     /usr/lib/locale/en_US.utf8/LC_TIME
b7842000-b7843000 r--p 00000000 08:01 415833     /usr/lib/locale/en_US.utf8/LC_MONETARY
b7843000-b7844000 r--p 00000000 08:01 415837     /usr/lib/locale/en_US.utf8/LC_MESSAGES/SYS_LC_MESSAGES
b7844000-b7845000 r--p 00000000 08:01 415710     /usr/lib/locale/en_US.utf8/LC_PAPER
b7845000-b7846000 r--p 00000000 08:01 415669     /usr/lib/locale/en_US.utf8/LC_NAME
b7846000-b7847000 r--p 00000000 08:01 415832     /usr/lib/locale/en_US.utf8/LC_ADDRESS
b7847000-b7848000 r--p 00000000 08:01 415838     /usr/lib/locale/en_US.utf8/LC_TELEPHONE
b7848000-b7849000 r--p 00000000 08:01 415667     /usr/lib/locale/en_US.utf8/LC_MEASUREMENT
b7849000-b7850000 r--s 00000000 08:01 294899     /usr/lib/gconv/gconv-modules.cache
b7850000-b7851000 r--p 00000000 08:01 415835     /usr/lib/locale/en_US.utf8/LC_IDENTIFICATION
b7851000-b7853000 rw-p 00000000 00:00 0
b7853000-b7854000 r-xp 00000000 00:00 0          [vdso]
b7854000-b786f000 r-xp 00000000 08:01 969        /lib/ld-2.11.1.so
b786f000-b7870000 r--p 0001a000 08:01 969        /lib/ld-2.11.1.so
b7870000-b7871000 rw-p 0001b000 08:01 969        /lib/ld-2.11.1.so
bfa54000-bfa75000 rw-p 00000000 00:00 0          [stack]
</code></pre>

<pre><code># cat /proc/self/maps
08048000-08054000 r-xp 00000000 08:01 261660     /bin/cat
08054000-08055000 r--p 0000b000 08:01 261660     /bin/cat
08055000-08056000 rw-p 0000c000 08:01 261660     /bin/cat
08f09000-08f2a000 rw-p 00000000 00:00 0          [heap]
b755b000-b759a000 r--p 00000000 08:01 415795     /usr/lib/locale/en_US.utf8/LC_CTYPE
b759a000-b759b000 r--p 00000000 08:01 415800     /usr/lib/locale/en_US.utf8/LC_NUMERIC
b759b000-b76b9000 r--p 00000000 08:01 415794     /usr/lib/locale/en_US.utf8/LC_COLLATE
b76b9000-b76ba000 rw-p 00000000 00:00 0
b76ba000-b780d000 r-xp 00000000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b780d000-b780e000 ---p 00153000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b780e000-b7810000 r--p 00153000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b7810000-b7811000 rw-p 00155000 08:01 5428       /lib/tls/i686/cmov/libc-2.11.1.so
b7811000-b7814000 rw-p 00000000 00:00 0
b7814000-b7815000 r--p 00000000 08:01 415834     /usr/lib/locale/en_US.utf8/LC_TIME
b7815000-b7816000 r--p 00000000 08:01 415833     /usr/lib/locale/en_US.utf8/LC_MONETARY
b7816000-b7817000 r--p 00000000 08:01 415837     /usr/lib/locale/en_US.utf8/LC_MESSAGES/SYS_LC_MESSAGES
b7817000-b7818000 r--p 00000000 08:01 415710     /usr/lib/locale/en_US.utf8/LC_PAPER
b7818000-b7819000 r--p 00000000 08:01 415669     /usr/lib/locale/en_US.utf8/LC_NAME
b7819000-b781a000 r--p 00000000 08:01 415832     /usr/lib/locale/en_US.utf8/LC_ADDRESS
b781a000-b781b000 r--p 00000000 08:01 415838     /usr/lib/locale/en_US.utf8/LC_TELEPHONE
b781b000-b781c000 r--p 00000000 08:01 415667     /usr/lib/locale/en_US.utf8/LC_MEASUREMENT
b781c000-b7823000 r--s 00000000 08:01 294899     /usr/lib/gconv/gconv-modules.cache
b7823000-b7824000 r--p 00000000 08:01 415835     /usr/lib/locale/en_US.utf8/LC_IDENTIFICATION
b7824000-b7826000 rw-p 00000000 00:00 0
b7826000-b7827000 r-xp 00000000 00:00 0          [vdso]
b7827000-b7842000 r-xp 00000000 08:01 969        /lib/ld-2.11.1.so
b7842000-b7843000 r--p 0001a000 08:01 969        /lib/ld-2.11.1.so
b7843000-b7844000 rw-p 0001b000 08:01 969        /lib/ld-2.11.1.so
bfb89000-bfbaa000 rw-p 00000000 00:00 0          [stack]
</code></pre>

<p>In the above output note that all the segments of the <code>/bin/cat</code> process
are mapped at different memory locations with each invocation. However,
closer look provides an interesting observation. The first three
segments that contain <code>.text</code> section of the binary (notice the r-x
permissions) are still mapped at similar locations each time. We have
enabled <em>ASLR</em> and it is indeed active, so why aren&#8217;t the <code>.text</code>
segments not mapped randomly? We will talk about this behavior in much
detail within the <em>PIE</em> section.</p>

<h3>Non-Executable Bit (NX)</h3>

<p>This feature disallows code execution from marked memory pages/segments.
It is also referred to as <em>W\^X</em> (W XOR X) due to the fact that the
pages marked with this feature could either be writable or executable
but not both at the same time. When enabled, a process&#8217;s memory
allocations, that do not contain instructions, will have only rw-
permissions assigned to them by default. As such, even if an attacker
successfully injects code into a writable memory region through an
overflow bug, an attempt to execute code from this section would still
fail. <em>NX</em> is enabled through the MMU by setting bit 63 of the <em>page
directory entry</em>. Important thing to note here is that this feature is
available only on those systems that have 64bit capability or on those
systems that use a PAE-enabled kernel. This is because on a regular
32bit kernel without PAE support, a <em>page directory entry</em> is just 32bit
wide and hence there is no room to store additional meta-information
about memory pages it points to. The <em>Execshield</em> and <em>Grsecurity</em> set
of kernel patches could also be used to simulate this behavior when the
above requirements could not be met:</p>

<pre><code># gcc -o test test.c 2&gt;/dev/null &amp;&amp; readelf -l test | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
#
# gcc -z execstack -o test test.c 2&gt;/dev/null &amp;&amp; readelf -l test | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4
#
# gcc -z noexecstack -o test test.c 2&gt;/dev/null &amp;&amp; readelf -l test | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
</code></pre>

<ul>
<li><code>-z execstack</code>: request the linker to mark program stack as executable</li>
<li><code>-z noexecstack</code>: request the linker to mark program stack as non-executable (recommended)</li>
</ul>

<p>Note the permissions of the <code>GNU_STACK</code> section in the above output.
When we request executable stack through the linker option, GCC marks
the stack as executable with RWE permissions. On my test system, which
is an Ubuntu 10.04 derivative with GCC version 4.4.3, the default
command-line disables executable stack markings as evident in the output
of first command-line. This behavior of implicitly enabling safeguards
makes an application immune to stack-based execution and other such
attacks even if the developer fails to include them during compilation.</p>

<h3>Stack Canaries / Stack-Smashing Protection (SSP)</h3>

<p>Stack Canaries are a protection feature that safeguard critical program
metadata information located on call stack. When enabled, a random
canary value is placed on the stack, just below the saved registers from
the function prologue. Before a program returns control to its parent,
the saved canary value is checked. Any attempts to overwrite the saved
return address on the stack will also overwrite the saved cookie and as
such the above check would fail. In such cases, the <code>__stack_chk_fail</code>
function is called, which displays a friendly <em>stack smashing detected</em>
message and aborts the execution of the program.This mitigation
technique also reorders the placement of local variables on the stack.
This is done to ensure that any variable, that directly influences the
program control and redirects its normal flow, is placed below a buffer
that accepts user-supplied input. Such a placement prevents overwriting
of variables placed adjacent to buffers. To read more about other such
novel ideas implemented in this protection technique, visit this link:
SSP</p>

<pre><code># gcc -fstack-protector -o test test.c 2&gt;/dev/null &amp;&amp; readelf -r test | grep _chk
0804a010  00000507 R_386_JUMP_SLOT   00000000   __stack_chk_fail
#
# gcc -fstack-protector-all -o test test.c 2&gt;/dev/null &amp;&amp; readelf -r test | grep _chk
0804a010  00000507 R_386_JUMP_SLOT   00000000   __stack_chk_fail
#
# gcc -fno-stack-protector -o test test.c 2&gt;/dev/null &amp;&amp; readelf -r test | grep _chk
</code></pre>

<p>The following options enable/disable this check:</p>

<ul>
<li><code>-fstack-protector</code>: enable checks for functions with character buffers of size 8B or higher</li>
<li><code>-fstack-protector-all</code>: enable checks for all functions (recommended)</li>
<li><code>-fno-stack-protector</code>: disable stack protection checks</li>
<li><code>-Wstack-protector</code>: emit warnings for all unprotected functions (recommended)</li>
<li><code>--param=ssp-buffer-size=&lt;size_in_bytes&gt;</code>: modifies the default 8B buffer lengthGCC versions 4.x include SSP techniques in their native implementations. Prior 3.x versions had this feature enabled through a patch.</li>
</ul>

<h3>FORTIFY_SOURCE</h3>

<p>There are cases when a compiler can correctly estimate the size of a
destination operand used in a certain string operation. For such cases,
the compiler could be requested to replace any vulnerable function calls
in the program source with their equivalent safer counterparts. This
would eventually make the compiled binary resilient to most overflow
attempts without significantly impacting its performance:</p>

<pre><code># gcc -O1 -D_FORTIFY_SOURCE=2 -o test test.c 2&gt;/dev/null &amp;&amp; readelf -r test | grep _chk
0804a004  00000207 R_386_JUMP_SLOT   00000000   __printf_chk
0804a008  00000307 R_386_JUMP_SLOT   00000000   __gets_chk
0804a010  00000507 R_386_JUMP_SLOT   00000000   __stack_chk_fail
</code></pre>

<p>In the above output you could see that the GCC option <code>-D_FORIFY_SOURCE</code>
has been used to include fortifying checks. The call for function
<code>printf</code> and <code>gets</code> were replaced with their safer equivalents,
<code>printf_chk</code> and <code>gets_chk</code> respectively. This option can accept two
values:</p>

<ul>
<li><code>-D_FORIFY_SOURCE=1</code>: to enable checks against buffer overflow attacks</li>
<li><code>-D_FORIFY_SOURCE=2</code>: to enable checks against buffer overflow and format string attacks (recommended)</li>
</ul>

<h3>RELocation Read-Only (RELRO)</h3>

<p>Another mitigation technique that safeguard against those exploits that
require <em>Global Offset Table (GOT)</em> modifications. For this to work, all
dynamic symbol resolutions, requested by a binary, have to be carried
out before the program execution begins. Once this is done, the GOT
could be marked as read-only, thus preventing any runtime modifications.</p>

<p>By default, when we use the GCC linker option <code>-Wl,-z,relro</code>, <em>PLT
(Procedure Linking Table)</em> entries, which include references for library
functions within a process&#8217;s memory allocation, are marked as writable
(lazy-linking). All other GOT entries apart from PLT remain read-only,
providing what is know as <em>Partial-RELRO</em> support:</p>

<pre><code># gcc -Wl,-z,norelro -o test test.c 2&gt;/dev/null &amp;&amp; readelf -l test | grep GNU_RELRO
#
# gcc -Wl,-z,relro -o test test.c 2&gt;/dev/null &amp;&amp; readelf -l test | grep GNU_RELRO
  GNU_RELRO      0x000f0c 0x08049f0c 0x08049f0c 0x000f4 0x000f4 R   0x1
#
# gcc -Wl,-z,relro,-z,now -o test test.c 2&gt;/dev/null &amp;&amp; readelf -l test | grep GNU_RELRO &amp;&amp; readelf -d test | grep BIND_NOW
  GNU_RELRO      0x000ee8 0x08049ee8 0x08049ee8 0x00118 0x00118 R   0x1
 0x00000018 (BIND_NOW)
</code></pre>

<p>The <code>-z,now</code> option ensures that PLT entries are resolved immediately
before execution, thus allowing the entire GOT to be marked as
read-only. This ensure that <code>Full-RELRO</code> support is enabled for the
compiled program. The summary for these options is:</p>

<ul>
<li><code>-Wl,-z,relro</code>: enables Partial RELRO support</li>
<li><code>-Wl,-z,relro,-z,now</code>: enables Full-RELRO support (recommended)</li>
</ul>

<h3>Position-Independent Executable (PIE)</h3>

<p>This feature helps to load a program at a random memory location on each
invocation. With <em>ASLR</em> enabled, the stack, heap, and mmap allocations
are automatically randomized. However, like we saw earlier with the
<em>/bin/cat</em> binary, the <code>.text</code> and other sections of a program are still
loaded at static addresses. To make all sections of a program to load at
random addresses, we need to compile it with PIE support:</p>

<pre><code># gcc -o test test.c 2&gt;/dev/null | file test | cut -d, -f1
test: ELF 32-bit LSB executable
#
# gcc -fpie -pie -o test test.c 2&gt;/dev/null | file test | cut -d, -f1
test: ELF 32-bit LSB executable
</code></pre>

<p>The following GCC options could be used to enable PIE support as evident
from the above output: <code>-fpie -pie</code> (recommended). Programs compiled
with this feature are marked as shared relocatable, much similar to
shared object libraries used in dynamic linking. To read more, visit
this link:
<a href="http://blog.fpmurphy.com/2008/06/position-independent-executables.html">PIE</a></p>

<p>Enabling these mitigation techniques will definitely improve the overall
security posture of a system, it still does not make it bullet-proof.
Some of these techniques might break compatibility with legacy
applications, while others might not work as expected. Different
distributions use different default configuration settings and as such
you can not simply standardize. The most suitable option would be to
test your application code first hand with each of these options,
carefully considering the tradeoffs and using only those that provide
that rare mix of security and usability.</p>

        </div>
        <div class="meta">
          <hr/>
          <p>For comments, questions and suggestions use <a href="https://twitter.com/7h3rAm" target="_blank">twitter</a> or create an <a href="https://github.com/7h3rAm/7h3rAm.github.io/issues/new" target="_blank">issue</a> on blog repository.</p>
          <hr/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <table>
                <tr>
                  <td align="left">(share via <a href="mailto:?subject=Exploit Mitigation Techniques on Linux Systems&body=http://7h3ram.github.io//2012/exploit-mitigation-techniques-on-linux.html" target="_blank" title="Share via Email">mail</a>, <a href="http://twitter.com/intent/tweet?text=Exploit Mitigation Techniques on Linux Systems+http://7h3ram.github.io//2012/exploit-mitigation-techniques-on-linux.html&via=7h3rAm" target="_blank" title="Share on Twitter">twitter</a>, <a href="http://www.facebook.com/sharer/sharer.php?s=100&p[url]=http://7h3ram.github.io//2012/exploit-mitigation-techniques-on-linux.html&p[images][0]=&p[title]=Exploit Mitigation Techniques on Linux Systems&p[summary]=This post discusses various exploit mitigation techniques like NX, ASLR, PIE and SSP available on modern Linux distributions." target="_blank" title="Share on Facebook">facebook</a> or <a href="https://plus.google.com/share?url=http://7h3ram.github.io//2012/exploit-mitigation-techniques-on-linux.html" target="_blank" title="Share on Google Plus">google-plus</a>)</td>
                  <td align="right">(tagged <a href=/tags.html#exploit>exploit</a> and <a href=/tags.html#mitigations>mitigations</a>)</td>
                </tr>
                <tr>
                                      <td align="left"><a href="/2012/vuln-weekends-8.html">&lt;&lt; Vulnerable Weekends #8: HP LoadRunner RCE &lt;&lt;</a></td>
                    <td align="right"><a href="/2012/geras-wuos-stack1-solutions.html">&gt;&gt; Gera's Warming Up on Stack #1 - Solutions &gt;&gt;</a></td>
                                  </tr>
              </table>
                                                                                                                                                                                                                                      </div>
        </div>
      </div>
    </div>
  </div>
  </article>
              <div class="footer">
          <center>
            <a href="/rss.xml" target="_blank">rss</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="license" target="_blank">license</a>
          </center>
        </div>
          </section>

    <script type="text/javascript">
      document.addEventListener("DOMContentLoaded", function() {
        var colors = ["#4B0082", "#3CB371", "#2E8B57", "#808000", "#20B2AA", "#008B8B", "#4682B4", "#B0C4DE", "#87CEFA", "#87CEEB", "#1E90FF", "#6495ED", "#000080", "#191970"];
        document.getElementById("element").style.color = colors[Math.floor(Math.random() * colors.length)];
      }, false);
    </script>

  </body>
</html>