<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="author" content="7h3rAm"/>
    <meta name="description" content="Personal Weblog"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>Grey Matter</title>

    <link href="/static/css/default.css" rel="stylesheet" type="text/css">
    <link href="/static/css/codehilite/perldoc.css" rel="stylesheet" type="text/css">

    <link href="/static/images/favicon-32x32.png" sizes="32x32" rel="icon" type="image/png"/>
  </head>
  <body>
    <section id="content" class="body">
              <div class="header">
          <table>
            <tr>
              <td class="blogtitle"><a href="/" style="color: rgb(102, 102, 102);">Grey Matter</a></td>
              <td class="blognavbar">
                [<a id="archive" href="/archive.html" style="color: rgb(70, 130, 180);">Archive</a>] [<a id="tags" href="/tags.html" style="color: rgb(255, 183, 69);">Tags</a>] [<a id="projects" href="/projects.html" style="color: rgb(0, 128, 128);">Projects</a>] [<a id="research" href="/research.html" style="color: rgb(242, 119, 122);">Research</a>]
              </td>
            </tr>
          </table>
        </div>
                  <article class="post">
  <div class="row">
    <div class="col-lg-12">
      <div class="panel panel-default section compact">
        <div class="body">
          <p class="heading">Developing a Minimal IPS from Scratch</p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <p class="date">
                  <a href="/2013/malsoftware-reverse-challenge.html">&lt&lt;</a> published on 15/Sep/2013<a href="/2013/regex-to-dotgraph.html"> &gt;&gt;</i></a><br/>
                </p>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <div class="post-content">
          <p><img src="/static/files/minips-arch.png" alt="image" /></p>

<p>Since it is a prevention system, an IPS has to be placed inline between
the firewall at the perimeter edge the default gateway of your network.
For any sessions that match inspection rules, they will be either
dropped or logged or both if required. This action is basically per
session/match configurable and can be changed through system&#8217;s policy
files. An inspection system needs network traffic as input and this
input can come from different sources but for the sake of simplicity,
we&#8217;ll only be focusing on packet capture files and direct network device
access as sources of input. Once the input is available in the form of
raw packets, the system will need to reassemble them and extract layer
payload which an inspection engine can consume.</p>

<p>Rule/Signature based inspection engines use custom variants of the PCRE
engine specifically optimized for performance and throughput. These
engines use different techniques for performing string matches, either
using native implementations of proven algorithms like <a href="http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm">Aho
Corasick</a>,
<a href="http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm">Boyer
Moore</a>,
<a href="http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm">Rabin
Karp</a>,
etc. <a href="http://en.wikipedia.org/wiki/Finite-state_machine">Finite State
Automaton</a> is also
used in some implementations. In this post, we&#8217;ll be using Libnids to
extract TCP streams/UDP packets and match user-supplied regular
expressions over this data. If a match is found, we&#8217;ll log details and
optionally drop the connection.</p>

<p>Before we begin with development, let&#8217;s design the pseudocode for our
IPS:</p>

<pre><code>1. initialize nids
2. register udp callback
3. register tcp callback
4. invoke nids session
5. for udp packet:
  5.1. extract source/destination and identify flow details
  5.2. extract payload and pass on to inspection engine
  5.3. if match found:
    5.3.1 dump source/destination details to output device/file
    5.3.2 dump match statistics to output device/file
6. for tcp packet:
  6.1 identify current tcp state
  6.2 if new connection:
    6.2.1 add source/destination to session table
    6.2.2 request cts/stc data collection from libnids
  6.3 elif existing connection with data:
    6.3.1 identify direction
    6.3.2 extract payload and pass on to inspection engine
    6.3.3 if match found:
      6.3.3.1 dump source/destination details to output device/file
      6.3.3.2 dump match statistics to output device/file
      6.3.3.3 stop cts/stc data collection
  6.4 elif existing connection with closing tcp sequence:
    6.4.1 stop cts/stc data collection
7. for each inspection request:
  7.1 match user-supplied regex over input data
  7.2 if match found:
    7.2.1 return match statistics
</code></pre>

<p>Please have a look at the <a href="https://gist.github.com/7h3rAm/10974463">minips.py</a> program which implements the above pseudo code.</p>

<p>It will inspect each TCP and UDP packet and for matching TCP streams,
stop tracking it any further. This is a performance optimization feature
with an understanding that if a stream matches certain regex, it is the
one the user intended to find. There is no need to inspect additional
data in the stream since it already has what the user intended to find.
This is only true for TCP streams as for UDP there is no stream/flow and
as such inspection always happens on a per-packet basis.</p>

<p>For streams/packets that match input expression, match direction (only
for TCP matches), start/end of match inside input buffer, match size etc
are dumped along with a hexdump of the matching content. To limit the
size of the hexdump output, a cli option is added. Regular expression
engine&#8217;s match behavior can be tweaked to enable case insensitive and
multiline matches using cli options.</p>

<p>Here is a test run of this program on a pcap that contains HTTP session
and UDP packets:</p>

<pre><code>$ python minips.py -p ~/toolbox/testfiles/pcaps/http.cap -r '.*com'
[15-Sep-2013 15:03:02.341813 IST] TCP 145.254.160.237:3372 - 65.208.228.223:80 (NEW)
[15-Sep-2013 15:03:02.341903 IST] TCP 145.254.160.237:3372 - 65.208.228.223:80 (CTS: 479B | STC: 0B)
[15-Sep-2013 15:03:02.341946 IST] TCP 145.254.160.237:3372 - 65.208.228.223:80 matches regex '.*com' @ CTS[29:51] 22B
00000000: 48 6f 73 74 3a 20 77 77 77 2e 65 74 68 65 72 65  |Host: www.ethere|
00000010: 61 6c 2e 63 6f 6d                                |al.com|

[15-Sep-2013 15:03:02.342179 IST] UDP 145.254.160.237:3009 - 145.253.2.203:53 (47B)
[15-Sep-2013 15:03:02.342210 IST] UDP 145.254.160.237:3009 - 145.253.2.203:53 matches regex '.*com' @ [0:42] 42B
00000000: 00 23 01 00 00 01 00 00 00 00 00 00 07 70 61 67  |.#...........pag|
00000010: 65 61 64 32 11 67 6f 6f 67 6c 65 73 79 6e 64 69  |ead2.googlesyndi|
00000020: 63 61 74 69 6f 6e 03 63 6f 6d                    |cation.com|

[15-Sep-2013 15:03:02.342439 IST] UDP 145.253.2.203:53 - 145.254.160.237:3009 (146B)
[15-Sep-2013 15:03:02.342479 IST] UDP 145.253.2.203:53 - 145.254.160.237:3009 matches regex '.*com' @ [0:42] 42B
00000000: 00 23 81 80 00 01 00 04 00 00 00 00 07 70 61 67  |.#...........pag|
00000010: 65 61 64 32 11 67 6f 6f 67 6c 65 73 79 6e 64 69  |ead2.googlesyndi|
00000020: 63 61 74 69 6f 6e 03 63 6f 6d                    |cation.com|
</code></pre>

<p>The program correctly identified regex match over the TCP stream in the
CTS (client-to-server) direction and dumped match statistics along with
matching content. The regex might have matched on the STC payload as
well but when the first match on this stream was found, the program
stopped tracking it any further and since that match was on CTS
direction, any payload following it was never seen. For UDP matches,
note that for the same flow, there are two matches: one while the data
is being sent from a client at UDP/3009 to server at UDP/53 and again
when the server replied to the client. Since, there are no flow details
for a UDP session, any such program won&#8217;t have an implicit knowledge of
the direction towards which payload is forwarded. However, it is not
trivial to implement such functionality in the UDP callback enabling it
to identify the client and server sides of the connection and then
taking appropriate action.</p>

<p>The <code>inspect</code> function currently only includes regex matches as the only
source of inspection over TCP/UDP payload but this can be extended to
add really interesting capabilities like <a href="/2013/libemu-shellcode-detection.html">shellcode
detection</a>,
<a href="http://code.google.com/p/yara-project/">Yara</a> rule matching, <a href="https://github.com/seatgeek/fuzzywuzzy">Fuzzy
String</a> matching, file
identification, file type based inspection, hash matching, javascript
extraction, deobfuscation, emulation and analysis, etc. I&#8217;ve been
working on a project which implements a few of these capabilities in
addition to various other nifty features desirable from such inspection
tools. Check it out @
<a href="https://github.com/7h3rAm/flowinspect">flowinspect</a>. The <code>minips.py</code>
program can also be extended to read input regex from a flat file and
match them in sequence over input packets. This will allow the user to
inspect network flows using multiple regexes, enabling true IPS-like
matching functionality.</p>

        </div>
        <div class="meta">
          <hr/>
          <p>For comments, questions and suggestions use <a href="https://twitter.com/7h3rAm" target="_blank">twitter</a> or create an <a href="https://github.com/7h3rAm/7h3rAm.github.io/issues/new" target="_blank">issue</a> on blog repository.</p>
          <hr/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <table>
                <tr>
                  <td align="left">(share via <a href="mailto:?subject=Developing a Minimal IPS from Scratch&body=http://7h3ram.github.io//2013/libnids-python-ids.html" target="_blank" title="Share via Email">mail</a>, <a href="http://twitter.com/intent/tweet?text=Developing a Minimal IPS from Scratch+http://7h3ram.github.io//2013/libnids-python-ids.html&via=7h3rAm" target="_blank" title="Share on Twitter">twitter</a>, <a href="http://www.facebook.com/sharer/sharer.php?s=100&p[url]=http://7h3ram.github.io//2013/libnids-python-ids.html&p[images][0]=&p[title]=Developing a Minimal IPS from Scratch&p[summary]=What do you get when you combine a TCP/IP reassembly/defragmentation library with Python's re module? Read on to know more." target="_blank" title="Share on Facebook">facebook</a> or <a href="https://plus.google.com/share?url=http://7h3ram.github.io//2013/libnids-python-ids.html" target="_blank" title="Share on Google Plus">google-plus</a>)</td>
                  <td align="right">(tagged <a href=/tags.html#code>code</a>)</td>
                </tr>
                <tr>
                                      <td align="left"><a href="/2013/malsoftware-reverse-challenge.html">&lt;&lt; reverse Challenge from Coursera's Malicious Software Course &lt;&lt;</a></td>
                    <td align="right"><a href="/2013/regex-to-dotgraph.html">&gt;&gt; Visualizing (non-POSIX) Regular Expressions &gt;&gt;</a></td>
                                  </tr>
              </table>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </div>
        </div>
      </div>
    </div>
  </div>
  </article>
              <div class="footer">
          <center>
            <a href="/rss.xml" target="_blank">rss</a> | <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="license" target="_blank">license</a>
          </center>
        </div>
          </section>

    <script type="text/javascript">
      document.addEventListener("DOMContentLoaded", function() {
        var colors = ["#4B0082", "#3CB371", "#2E8B57", "#808000", "#20B2AA", "#008B8B", "#4682B4", "#B0C4DE", "#87CEFA", "#87CEEB", "#1E90FF", "#6495ED", "#000080", "#191970"];
        document.getElementById("element").style.color = colors[Math.floor(Math.random() * colors.length)];
      }, false);
    </script>

  </body>
</html>